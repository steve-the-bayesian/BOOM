// Copyright 2018 Google LLC. All Rights Reserved.
/*
  Copyright (C) 2007 Steven L. Scott

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
*/

#ifndef BOOM_HMM_FILTER_HPP
#define BOOM_HMM_FILTER_HPP

#include "LinAlg/Matrix.hpp"
#include "Models/MarkovModel.hpp"
#include "cpputil/Ptr.hpp"
#include "cpputil/RefCounted.hpp"
#include "distributions/rng.hpp"

namespace BOOM {
  class Model;
  class Data;
  class EmMixtureComponent;
  class HiddenMarkovModel;

  class HmmFilter : private RefCounted {
   public:
    friend void intrusive_ptr_add_ref(HmmFilter *d) { d->up_count(); }
    friend void intrusive_ptr_release(HmmFilter *d) {
      d->down_count();
      if (d->ref_count() == 0) delete d;
    }

    HmmFilter(const std::vector<Ptr<MixtureComponent>> &mix,
              const Ptr<MarkovModel> &mark);
    ~HmmFilter() override {}
    uint state_space_size() const;

    double initialize(const Data *);
    double loglike(const std::vector<Ptr<Data>> &);

    // The HMM forward algorithm.  Iterate forward through data_series, updating
    // joint_distributions_ as information is accumulated at each step.  Return
    // the log likelihood of data_series.
    //
    // Args:
    //   data_series:  The series of data to be processed.
    //
    // Returns:
    //   The log likelihood of the current model parameters under 'data_series'.
    //
    // Effects:
    //   - joint_distributions_[t] is updated for each t in 1...n-1 (where n is
    //     the length of data_series)
    //   - marginal_distribution_ is set to the column margin of
    //     joint_distributions_.back().
    double fwd(const std::vector<Ptr<Data>> &data_series);

    // After a call to fwd, a call to bkwd_sampling_mt simulates a random state
    // at each time point conditional on all the observed data.
    //
    // Args:
    //   data_series:  The series being processed.
    //   rng:  The random number generator used to drive the simulation.
    //
    // Effects:
    //   Each data point is assigned to one of the models.  Sufficient
    //   statistics for the Markov model are updated.
    void bkwd_sampling_mt(const std::vector<Ptr<Data>> &data_series, RNG &rng);

    // The state vector that was imputed for data during the call to
    // bkwd_sampling or bkwd_sampling_mt.
    const std::vector<int> &imputed_states() const {
      return imputed_states_;
    }

   protected:
    // The mixture componenst comprising the hidden Markov model.
    std::vector<Ptr<MixtureComponent>> models_;

    // The model object containing the transition probabilities and initial
    // state distribution for the hidden Markov chain.
    Ptr<MarkovModel> markov_;

    // joint_distributions_[t] is the joint distribution of the hidden states
    // h[t-1], h[t] at times t and t-1, given data to time t.
    std::vector<Matrix> joint_distributions_;

    // Workspace for computing marginals from joint_distributions_.
    Vector marginal_distribution_;

    // More workspace
    Vector logp;
    Vector logpi;

    // A vector of all 1's
    Vector one;

    // Workspace for the log of the Markov transition probabilities.
    Matrix logQ;

    // The most recent set of imputed states generated by bkwd_sampling_mt.
    std::vector<int> imputed_states_;
  };

  //----------------------------------------------------------------------
  class HmmEmFilter : public HmmFilter {
   public:
    HmmEmFilter(const std::vector<Ptr<EmMixtureComponent>> &mix,
                const Ptr<MarkovModel> &mark);
    void bkwd_smoothing(const std::vector<Ptr<Data>> &);
   private:
    std::vector<Ptr<EmMixtureComponent>> em_models_;
  };

}  // namespace BOOM

#endif  // BOOM_HMM_FILTER_HPP
