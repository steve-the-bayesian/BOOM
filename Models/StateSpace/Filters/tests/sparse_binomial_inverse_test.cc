#include "gtest/gtest.h"

#include "Models/StateSpace/Filters/SparseMatrix.hpp"
#include "Models/StateSpace/StateModels/SemilocalLinearTrend.hpp"
#include "Models/StateSpace/StateModels/SeasonalStateModel.hpp"
#include "Models/StateSpace/AggregatedStateSpaceRegression.hpp"
#include "Models/TimeSeries/ArmaModel.hpp"

#include "distributions.hpp"
#include "LinAlg/DiagonalMatrix.hpp"

#include "test_utils/test_utils.hpp"

namespace {

  using namespace BOOM;

  // SparseBinomialInverse is also tested in the general sparse_matrix_test.cc
  // file.
  class SparseBinomialInverseTest : public ::testing::Test {
   protected:
    SparseBinomialInverseTest() : big_dim_(10),
                                  lil_dim_(3)
    {
      GlobalRng::rng.seed(8675309);
      Vector diagonal_elements(big_dim_);
      diagonal_elements.randomize();
      diagonal_elements = diagonal_elements * diagonal_elements;
      Ainv_.reset(new DiagonalMatrixBlock(diagonal_elements));
      double logdet = sum(log(diagonal_elements));

      Matrix Uelements(big_dim_, lil_dim_);
      Uelements.randomize();
      U_.reset(new DenseMatrix(Uelements));

      B_ = SpdMatrix(lil_dim_);
      B_.randomize();

      Finv_.reset(new SparseBinomialInverse(Ainv_, U_, B_, logdet));

      Matrix A(big_dim_, big_dim_, 0.0);
      A.diag() = 1.0 / diagonal_elements;
      F_ = A + Uelements * B_ * Uelements.transpose();
    }

    int big_dim_;
    int lil_dim_;

    Ptr<SparseKalmanMatrix> Ainv_;
    Ptr<SparseKalmanMatrix> U_;
    SpdMatrix B_;

    Ptr<SparseBinomialInverse> Finv_;
    SpdMatrix F_;

  };

  TEST_F(SparseBinomialInverseTest, Multiply) {
    Vector x(big_dim_);
    x.randomize();

    Vector y1 = *Finv_  * x;
    SpdMatrix Finv = F_.inv();
    Vector y2 = Finv * x;

    EXPECT_TRUE(VectorEquals(y1, y1));
  }

  TEST_F(SparseBinomialInverseTest, Inverse) {
    Matrix Id = *Finv_ * F_;

    EXPECT_EQ(Id.nrow(), big_dim_);
    EXPECT_EQ(Id.ncol(), big_dim_);

    EXPECT_TRUE(VectorEquals(Id.diag(), Vector(big_dim_, 1.0)));
    Id.diag() = 0.0;

    EXPECT_LT(Id.max_abs(), .00001);
  }

  // A Kalman filter calculation involving Finv (a SparseBinomialInverse matrix)
  // was failing.  This test captured the data in the calculation to ensure that
  // the dense and sparse calculations were the same, up to numerical error.
  TEST_F(SparseBinomialInverseTest, RealFailure) {

    // Capture the data used to create the SparseBinomialInverse.
    Vector Ainv_diag = {11.917, 15.1, 16.906, 13.081, 23.877, 16.634, 11.114,
      8.3906, 2.6177, 39.301, 9.922, 2.042, 1.9156, 1.2439, 49.007, 32.899,
      9.3256, 15.931, 32.714, 14.447, 8.313, 5.1866, 14.97, 12.321, 10.342,
      34.457, 7.3832, 8.8887, 4.2634, 9.3058, 9.9771, 9.9913, 9.5705,
      35.639, 14.543, 0.92551, 7.2277, 17.76, 16.205, 20.956, 15.704,
      7.9992, 5.0917, 6.9571, 3.1435, 22.616, 3.2753, 14.844, 19.305,
      0.49551, 2.6025, 6.7193, 8.6977, 12.107, 25.56, 9.3878, 1.059, 3.7523,
      14.25, 7.1969, 43.392, 3.9044, 12.831, 15.84, 15.73, 19.728, 22.865,
      14.714, 4.453, 30.322, 3.8338, 21.966, 2.578, 35.847, 7.8668, 19.472,
      1.8576, 47.843, 11.238, 8.9015, 11.625, 12.647, 5.2559, 15.905, 8.442,
      5.2453, 4.3812, 1.7911, 2.9108, 7.7601, 4.8538, 8.5783, 11.764, 9.4237,
      3.1832, 4.3873, 5.2796, 8.4695, 9.0806, 9.8767, 4.6905, 11.881, 11.977,
      11.353, 6.8963, 8.3548, 6.7517, 8.1832, 10.833, 7.1357, 3.2727, 3.9854,
      10.678, 7.6381, 10.228, 9.4463, 13.251, 17.011, 7.9672, 1.6972, 9.8984,
      4.6023, 3.1255, 8.1458, 2.0713, 0.7437, 9.3014, 14.645, 11.597, 11.102,
      4.958, 12.22, 10.477, 11.99, 11.171, 2.1407, 2.7137, 5.8618, 2.0541,
      19.114, 9.7249, 13.13, 5.0076, 7.452, 9.8758, 4.0673, 10.665, 15.569,
      11.405, 11.821, 20.609, 16.972, 5.4129, 0.96052, 12.196, 16.141, 1.2851,
      3.1608, 18.525, 0.40486, 22.81, 24.11, 6.8479, 14.075, 9.994, 7.6051,
      11.601, 37.728, 22.961, 3.723, 16.946, 17.547, 2.5993, 3.2497, 4.8645,
      40.263, 7.1921, 14.278, 11.915, 14.626, 12.45, 33.917, 45.526, 25.198,
      11.233, 2.67, 12.144, 27.064, 26.785, 21.323, 9.0525, 35.4, 22.941,
      1.7766, 26.909, 1.8398, 21.625, 0.99193, 1.1493, 38.298, 7.5275,
      0.66909, 32.213, 62.631, 32.96, 21.91, 12.196, 32.77, 35.728, 37.659,
      17.121, 0.97747, 29.302, 16.214, 44.931, 18.953, 41.592, 7.2038,
      27.593, 55.387, 1.4305, 12.855};

    Matrix Ainv(222, 222, 0.0);
    Ainv.diag() = Ainv_diag;

    Vector B_elements = {
      1.0034, 0, 0, 0, 0, 0, 0, 0, 6.0202, -1.0034, -1.0034, -1.0034,
      -1.0034, -1.0034, 0, -1.0034, 1.0034, 0, 0, 0, 0, 0, -1.0034, 0,
      1.0034, 0, 0, 0, 0, -1.0034, 0, 0, 1.0034, 0, 0, 0, -1.0034, 0, 0, 0,
      1.0034, 0, 0, -1.0034, 0, 0, 0, 0, 1.0034};
    SpdMatrix B(7, B_elements.data(), false);

    Vector U_elements = {
      -93.308, 14.175, 253.13, -381.89, 67.312, 123.6, 165.12, -2.3567, 118.97,
      135.47, -99.61, -380.72, -221.12, 165.51, -44.286, 181.97, -303.28,
      -344.01, -73.7, 98.425, 209.5, 149.25, 120.97, -141.21, -69.26, -251.07,
      124.03, -77.442, -317.76, -403.27, -4.0574, -369.31, -131.42, -116.38,
      132.79, -117.89, 22.864, -173.53, 84.134, -126.94, -117.3, 277.36,
      245.72, 148.82, -249.28, 183.01, -169.29, -100.52, -3.0977, -1524.3,
      -1111.8, 406.09, -120, -37.07, -17.193, -260.37, -2466.7, 319.43, -230.49,
      38.537, -112.18, 680.44, 23.228, 244.76, -383.15, -23.212, 8.006, -49.787,
      -76.64, -90.319, -18.285, 172, -607.41, -67.917, 68.674, 28.945, -32.743,
      9.7859, 72.851, -181.32, 137.78, 103.85, 457.56, -375.34, -31.561, 170.33,
      -334.11, 322.67, 44.887, -179.64, -237.19, -126.71, -38.228, 261.57,
      -3.4835, 387.58, -388.45, -116.32, -110.45, -158.63, -72.394, -44.566,
      198.64, -215.93, 451.74, 230.3, 41.003, -11.63, 848.72, -199.25, -4.9543,
      732.52, 192.73, 140.88, 43.125, 167.63, -155.85, 49.481, -58.066, -519.67,
      -306.84, -465.3, -60.861, -268.34, -218.12, 764.01, -171.47, -274.29,
      333.17, -248.43, 204.44, 92.205, -15.331, -266.69, 177.29, 365.14, 325.33,
      -177.02, -390.21, 14.628, -79.384, 114.17, -373.83, -98.833, 524.95,
      -159.47, 14.655, 37.213, 58.853, -23.902, 423.1, -154.26, 187.05, -53.451,
      -277.92, -35.894, -648.67, 67.668, -61.807, -294.9, -125.53, 1.2641,
      190.74, -6.7751, -241.41, -79.625, 12.869, 168.26, 404.94, 711.6, -83.713,
      32.974, -636.1, -872.29, -84.867, -38.376, 14.957, -433.84, -108.32,
      84.102, 334.76, -59.811, 100.03, -287.37, -459.69, -721.81, -347.21,
      240.14, -160.29, 422.48, -458.86, -72.575, 66.82, -861.51, 458.72, 1263,
      -222.47, -1268.5, 742.28, -158.21, 314.85, 1625.4, 301.18, 314.77, 6.7206,
      -73.86, -76.448, 80.679, 20.874, 109.38, 77.368, 547.01, 373.91, -266.68,
      98.898, 1012.5, -1062.5, 133.22, 412.76, -217.02, -1489.2, -181.15,
      -93.308, 14.175, 253.13, -381.89, 67.312, 123.6, 165.12, -2.3567, 118.97,
      135.47, -99.61, -380.72, -221.12, 165.51, -44.286, 181.97, -303.28,
      -344.01, -73.7, 98.425, 209.5, 149.25, 120.97, -141.21, -69.26, -251.07,
      124.03, -77.442, -317.76, -403.27, -4.0574, -369.31, -131.42, -116.38,
      132.79, -117.89, 22.864, -173.53, 84.134, -126.94, -117.3, 277.36, 245.72,
      148.82, -249.28, 183.01, -169.29, -100.52, -3.0977, -1524.3, -1111.8,
      406.09, -120, -37.07, -17.193, -260.37, -2466.7, 319.43, -230.49, 38.537,
      -112.18, 680.44, 23.228, 244.76, -383.15, -23.212, 8.006, -49.787, -76.64,
      -90.319, -18.285, 172, -607.41, -67.917, 68.674, 28.945, -32.743, 9.7859,
      72.851, -181.32, 137.78, 103.85, 457.56, -375.34, -31.561, 170.33,
      -334.11, 322.67, 44.887, -179.64, -237.19, -126.71, -38.228, 261.57,
      -3.4835, 387.58, -388.45, -116.32, -110.45, -158.63, -72.394, -44.566,
      198.64, -215.93, 451.74, 230.3, 41.003, -11.63, 848.72, -199.25, -4.9543,
      732.52, 192.73, 140.88, 43.125, 167.63, -155.85, 49.481, -58.066, -519.67,
      -306.84, -465.3, -60.861, -268.34, -218.12, 764.01, -171.47, -274.29,
      333.17, -248.43, 204.44, 92.205, -15.331, -266.69, 177.29, 365.14, 325.33,
      -177.02, -390.21, 14.628, -79.384, 114.17, -373.83, -98.833, 524.95,
      -159.47, 14.655, 37.213, 58.853, -23.902, 423.1, -154.26, 187.05, -53.451,
      -277.92, -35.894, -648.67, 67.668, -61.807, -294.9, -125.53, 1.2641,
      190.74, -6.7751, -241.41, -79.625, 12.869, 168.26, 404.94, 711.6, -83.713,
      32.974, -636.1, -872.29, -84.867, -38.376, 14.957, -433.84, -108.32,
      84.102, 334.76, -59.811, 100.03, -287.37, -459.69, -721.81, -347.21,
      240.14, -160.29, 422.48, -458.86, -72.575, 66.82, -861.51, 458.72, 1263,
      -222.47, -1268.5, 742.28, -158.21, 314.85, 1625.4, 301.18, 314.77,
      6.7206, -73.86, -76.448, 80.679, 20.874, 109.38, 77.368, 547.01, 373.91,
      -266.68, 98.898, 1012.5, -1062.5, 133.22, 412.76, -217.02, -1489.2,
      -181.15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0};
    Matrix U(222, 7, U_elements.data(), true);

    Matrix A = Ainv.inv();
    double Ainv_logdet = sum(log(Ainv_diag));
    Matrix F = A + U * B * U.transpose();
    Matrix Finv_dense = F.inv();

    // Create the Sparse versions of the relevant matrices.
    NEW(DiagonalMatrixBlock, Ainv_ptr)(Ainv_diag);
    NEW(DenseMatrix, U_ptr)(U);
    SparseBinomialInverse Finv_sparse(Ainv_ptr, U_ptr, B, Ainv_logdet);

    // Check that the SparseBinomialInverse is actually the inverse of the dense
    // matrix.
    Matrix Id1 = Finv_sparse * F;
    Matrix Id2 = Finv_dense * F;
    EXPECT_TRUE(MatrixEquals(Id1, Id2, 1e-5))
        << "max(abs(Id1 - Id2)) = " << (Id1 - Id2).max_abs();

    // Check that the dense() method of Finv_sparse actually recovers the dense
    // matrix.
    EXPECT_TRUE(MatrixEquals(Finv_dense, Finv_sparse.dense(), 1e-6))
        << "max(abs(Finv_dense - Finv_sparse.dense())) = "
        << (Finv_dense - Finv_sparse.dense()).max_abs();

    // Check out the calculation that appears to have failed in the Kalman
    // filter code:  P * Z' * Finv * Z * P is being thrown as non-symmetric.
    //
    // Note that U and Z are the same thing here.  'U' is binomial inverse
    // notation.  'Z' is Kalman filter notation.  But they're the same matrix.
    Vector P_elements = {1.0034, 0, 0, 0, 0, 0, 0, 0, 6.0202, -1.0034, -1.0034,
      -1.0034, -1.0034, -1.0034, 0, -1.0034, 1.0034, 0, 0, 0, 0, 0, -1.0034, 0,
      1.0034, 0, 0, 0, 0, -1.0034, 0, 0, 1.0034, 0, 0, 0, -1.0034, 0, 0, 0,
      1.0034, 0, 0, -1.0034, 0, 0, 0, 0, 1.0034};
    SpdMatrix P(7, P_elements.data());

    // Step through the series of matrix calculations using both dense and
    // sparse math.
    Matrix m1 = *U_ptr * P;
    Matrix mm1 = U * P;
    EXPECT_TRUE(MatrixEquals(m1, mm1));

    Matrix m2 = Finv_sparse * (*U_ptr * P);
    Matrix mm2 = Finv_dense * U * P;
    EXPECT_TRUE(MatrixEquals(m2, mm2));

    Matrix m3 = U_ptr->Tmult(Finv_sparse * (*U_ptr * P));
    Matrix mm3 = U.transpose() * Finv_sparse * U * P;
    EXPECT_TRUE(MatrixEquals(m3, mm3, 3e-6))
        << "m3 = \n" << m3
        << "mm3 = \n" << mm3
        << "max(abs(m3 - mm3)) = " << (m3 - mm3).max_abs();

    Matrix m4 = P * (U_ptr->Tmult(Finv_sparse * (*U_ptr * P)));
    Matrix mm4 = P * U.transpose() * Finv_sparse * U * P;

    EXPECT_TRUE(MatrixEquals(m4, mm4, 4e-6))
        << "m4 = \n" << m4
        << "mm4 = \n" << mm4
        << "max(abs(m4 - mm4)) = " << (m4 - mm4).max_abs();

  }


}  // namespace
